#pragma config(Hubs,  S1, HTServo,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Hubs,  S3, HTMotor,  none,     none,     none)
#pragma config(Hubs,  S4, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,                    sensorI2CMuxController)
#pragma config(Sensor, S2,     HeightTouch,         sensorI2CMuxController)
#pragma config(Sensor, S3,     MagneticSensor,      sensorI2CMuxController)
#pragma config(Sensor, S4,     Accel,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     motorD,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorE,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S3_C1_1,     motorF,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S3_C1_2,     motorG,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S4_C1_1,     motorH,        tmotorNone, openLoop)
#pragma config(Motor,  mtr_S4_C1_2,     motorI,        tmotorNone, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    ArmLeft1,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    ArmLeft2,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    ArmRight1,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    ArmRight2,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    Gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*#pragma config(Hubs,  S1, HTServo,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     HeightTouch,         sensorTouch)
#pragma config(Sensor, S3,     MagneticSensor,      sensorI2CHiTechnicCompass)
#pragma config(Sensor, S4,     Accel,               sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C3_1,     LeftDrive,     tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     RightDrive,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_1,     Gatherer,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_2,     Lift,          tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    ArmLeft1,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    ArmLeft2,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    ArmRight1,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    ArmRight2,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_6,    Gate,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C2_1,    TouchServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    MagnetBlocker,        tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    BackHolder1,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    BackHolder2,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_6,    FrontHolder,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*/

/*
Port 1: Arm Servos -> Auxiliary Servos -> Drive Motors -> Gatherer Motors
Port 2: Touch Sensor
Port 3: Magnetic Sensor
Port 4: Accelerometer
*/
#include "JoystickDriver.c"	 //Include file to "handle" the Bluetooth messages.
#include "TeleOpHeaders.h"		 //Include file which has headers such as global variables

#include "HTMAG-driver.h"
bool magnetIn = false;
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																		Initialize Robot
//  -Reset the Backholders
//  -Reset the Front Holder
//  -Close the basket Gate
//  -Lower the MagnetBlocker
//  -Lower the Basket and arm
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{


  servo[BackHolder1] = 128;
  servo[BackHolder2] = 128;
  servo[FrontHolder] = 25; //Reset position
  servo[Gate] = 84; //Reset position
  servo[MagnetBlocker] = 120;

  servo[ArmLeft1] = ArmLeft1num;//always 7 more
  servo[ArmLeft2] = ArmLeft2num;
  servo[ArmRight1] = ArmRight1num;//always 5 less than Right 2
  servo[ArmRight2] = ArmRight2num;
  wait1Msec(500);
  return;
  wait1Msec(500);
  return;
}


task main()
{
  initializeRobot();
  waitForStart();		// wait for start of tele-op phase
  StartTask(shortDrive);
  while (true)
  {
    getJoystickSettings(joystick);
    //Check the joystick values and move accordingly//

    checkJoy1_y1();
    checkJoy1_y2();
    checkButtonsJoy1();
    checkJoy2_y1();
    checkJoy2_y2();
    checkButtonsJoy2();
  }
}

void checkButtonsJoy1()
{

  if (joy1Btn(1))
  {
    speed = .25;
  }
  if (joy1Btn(2))
  {
    speed = .50;

  }
  if (joy1Btn(3))
  {
    speed = .75;

  }
  if (joy1Btn(4))
  {
    speed = 1;
  }
  if (joy1Btn(9))
  {
    servo[BackHolder1] = 0;
    servo[BackHolder2] = 255;
  }
  if (joy1Btn(10))
  {
    servo[BackHolder1] = 128;
    servo[BackHolder2] = 128;
  }
  if (joy1Btn(5))
  {
    servo[FrontHolder] = 140;
  }
  else
  {
    servo[FrontHolder] = 5;
  }

  if (joy1Btn(6))
  {

  }

}
void MissionImpossible()
{
  //        100 = Tempo
  //          6 = Default octave
  //    Quarter = Default note length
  //        10% = Break between notes
  //
  /*for(int i = 0; i<500; i++)
  {
      PlayTone(  230,    7); wait1Msec(  75);  // Note(D, Duration(32th))
      PlayTone(  300,    7); wait1Msec(  75);  // Note(D, Duration(32th))
      PlayTone(  100,    7); wait1Msec(  75);  // Note(D, Duration(32th))
      PlayTone(  400,    7); wait1Msec(  75);  // Note(D, Duration(32th))
      PlayTone(  200,    7); wait1Msec(  75);  // Note(D, Duration(32th))
      PlayTone(  800,    7); wait1Msec(  75);  // Note(D, Duration(32th))
      PlayTone(  900,    7); wait1Msec(  75);  // Note(D, Duration(32th))
            PlayTone(  200,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  }*/
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  880,    7); wait1Msec(  75);  // Note(D, Duration(32th))
  PlayTone(  933,    7); wait1Msec(  75);  // Note(D#, Duration(32th))
  PlayTone(  988,    7); wait1Msec(  75);  // Note(E, Duration(32th))
  PlayTone( 1047,    7); wait1Msec(  75);  // Note(F, Duration(32th))
  PlayTone( 1109,    7); wait1Msec(  75);  // Note(F#, Duration(32th))
  PlayTone( 1175,    7); wait1Msec(  75);  // Note(G, Duration(32th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(    0,   27); wait1Msec( 300);  // Note(Rest, Duration(Eighth))
  PlayTone( 1047,   14); wait1Msec( 150);  // Note(F, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone( 1109,   14); wait1Msec( 150);  // Note(F#, Duration(16th))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(  880,  108); wait1Msec(1200);  // Note(D, Duration(Half))
  PlayTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
  PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(  831,  108); wait1Msec(1200);  // Note(C#, Duration(Half))
  PlayTone(    0,    7); wait1Msec(  75);  // Note(Rest, Duration(32th))
  PlayTone( 1398,   14); wait1Msec( 150);  // Note(A#, Duration(16th))
  PlayTone( 1175,   14); wait1Msec( 150);  // Note(G, Duration(16th))
  PlayTone(  784,  108); wait1Msec(1200);  // Note(C, Duration(Half))
  PlayTone(    0,   14); wait1Msec( 150);  // Note(Rest, Duration(16th))
  PlayTone(  932,   14); wait1Msec( 150);  // Note(A#5, Duration(16th))
  PlayTone(  784,   14); wait1Msec( 150);  // Note(C, Duration(16th))
  return;
}


void checkButtonsJoy2()
{
  if (joy2Btn(1))
  {
    servo[MagnetBlocker] = 120;

  }
  if (joy2Btn(2))
  {
    servo[MagnetBlocker] = 0;
  }
  if (joy2Btn(3))
  {
  servo[TouchServo] = 90;
  }
  if (joy2Btn(4))
  {
servo[TouchServo] = 190;
  }
  if (joy2Btn(5)&&SensorValue[HeightTouch] == 0)
  {
    motor[Lift] = -50;
  }
  else if (joy2Btn(6))
  {
    motor[Lift] = 30;
  }
  else
  {
    motor[Lift] = 0;
  }
  //Stuff I need to fix
  if (joy2Btn(8))
  {
      servo[ArmLeft1] +=1;
      servo[ArmLeft2] += 1;

      servo[ArmRight1] -=1;
      servo[ArmRight2] -= 1;

  }
  else if (joy2Btn(7))
  {
    servo[ArmLeft1] -=1;
      servo[ArmLeft2] -= 1;

      servo[ArmRight1] +=1;
      servo[ArmRight2] += 1;
  }
  if (joy2Btn(9) && joy2Btn(10))
  {

      MissionImpossible();

  }
  if (joy2Btn(9))
  {

      servo[Gate] = 95;

  }
  else
  {
     servo[Gate] = 70;
  }
  if (joy2Btn(10))
  {



  }
}
task stopGatherMagnet
{

     wait1Msec(2000);
       magnetIn = true;
      motor[Gatherer] = 0;
      wait1Msec(3000);
      magnetIn = false;
}

void checkJoy2_y1()
{
  if ((joystick.joy2_y1 > 50 || joystick.joy2_y1 < -50) && magnetIn == false)
  {
    motor[Gatherer] = (joystick.joy2_y1 * (.25));
    if ((HTMAGreadVal(MagneticSensor)>0)||(HTMAGreadVal(MagneticSensor)<-12))
    {
      servo[MagnetBlocker] = 0;
     StartTask(stopGatherMagnet);
    }
  }
  else
  {
    motor[Gatherer] = 0;
  }
}
int joycounts1 = 0;
void checkJoy2_y2()
{

}
void checkJoy1_y1()
{

  if ((parallelDrive == false)&& nudgeDrive == false)
  {
    if (joystick.joy1_y1 > 25 || joystick.joy1_y1 < -25)
    {
      motor[LeftDrive] =  (joystick.joy1_y1 * speed * 100) / 128;
    }
    //if not, it will stop the left drive
    else if ( -25 < joystick.joy1_y1 < 25)
    {
      motor[LeftDrive] = 0;
   motor[RightDrive] = 0;
  } }
  else if (nudgeDrive == false)
  {
    if (joystick.joy1_y1 > 25 || joystick.joy1_y1 < -25)
    {
      motor[LeftDrive] = (joystick.joy1_y1*speed * 100) / 128;
      motor[RightDrive] = (joystick.joy1_y1*speed * 100) / 128;
    }
    else if ( -25 < joystick.joy1_y1 < 25 )
    {
      motor[LeftDrive] = 0;
      motor[RightDrive] = 0;
    }
  }
}
void checkJoy1_y2()
{
  //If joystick 1 of Y2 is pressed, Right motor wil move at 'speed'
  //getJoystickSettings(joystick);
  if (nudgeDrive == false)
  {
    if (joystick.joy1_y2 > 25 || joystick.joy1_y2 < -25)
    {
      motor[RightDrive] = (joystick.joy1_y2*speed * 100) / 128;
    }
    else if ( -25 < joystick.joy1_y2 < 25)
    {
      motor[RightDrive] = 0;
    }
  }
}
/////////////////////////////////Nudge Drive/////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////
task shortDrive ()
{
  while (true)
  {
    nMotorEncoder[LeftDrive] = 0;
    nMotorEncoder[RightDrive] = 0;
    wait1Msec(300);

    getJoystickSettings(joystick);
    //eraseDisplay();
    //nxtDisplayStringAt(15,14, "POV:"+ joystick.joy1_TopHat);

    if ((int)(joystick.joy1_TopHat)==-1)
    {
      nudgeDrive = false;

    }
    if ((int)(joystick.joy1_TopHat)==4)
    {
      nudgeDrive = true;
      goInches(.1,-75);
    }
    if ((int)(joystick.joy1_TopHat)==0)
    {
      nudgeDrive = true;
      goInches(.1,75);

    }
    if ((int)(joystick.joy1_TopHat)==6)
    {
      nudgeDrive = true;
      goTurn(1,-75);

    }
    if ((int)(joystick.joy1_TopHat)==2)
    {
      nudgeDrive = true;
      goTurn(1,75);

    }

  }
}

void goInches(float inches, int speed)
{
  //reset the encoders...
  nMotorEncoder[RightDrive] = 0;
  nMotorEncoder[LeftDrive] = 0;
wait1Msec(300);
  //start up the motors...
  motor[LeftDrive] = speed;
  motor[RightDrive] = speed;
  //you go move until you reach the desired amount of encoder counts...
  while (abs(nMotorEncoder[RightDrive]) < (convert(inches)) || abs(nMotorEncoder[LeftDrive]) < (convert(inches))){ }
  //You stop the motors after the while loop...
  motor[LeftDrive] = 0;
  motor[RightDrive] = 0;
  //wait1Msec (200);
}
void goTurn(float Degree, int speed)
{
  //reset the encoders...
  nMotorEncoder[RightDrive] = 0;
  nMotorEncoder[LeftDrive] = 0;

  //start up the motors...
  motor[LeftDrive] = -speed;
  motor[RightDrive] = speed;
  //you go move until you reach the desired amount of encoder counts...
  while ((abs(nMotorEncoder[RightDrive]) < (convertDegree(Degree))) || abs(nMotorEncoder[LeftDrive]) < (convertDegree(Degree))){ }
  //You stop the motors after the while loop...
  motor[LeftDrive] = 0;
  motor[RightDrive] = 0;

}
long convertDegree(float Degree)
{
  //In this part, you convert the inches to encoder rotations and you return that value//
  return (Degree* 16.1);
}
long convert(float inches)
{
  //In this part, you convert the inches to encoder rotations and you return that value//
  return (inches* 112);
}
