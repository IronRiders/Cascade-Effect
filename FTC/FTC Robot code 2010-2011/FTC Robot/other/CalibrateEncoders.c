#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  HTServo,  none,     none)
#pragma config(Sensor, S3,     touchMux,            sensorHiTechnicTouchMux)
#pragma config(Sensor, S4,     Accel,               sensorI2CHiTechnicAccel)
#pragma config(Motor,  mtr_S1_C1_1,     LeftDrive,     tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RightDrive,    tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     Gatherer,      tmotorNormal, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     Lift,          tmotorNormal, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    ,                     tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    armLeft1,             tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    armLeft2,             tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    armRight1,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_5,    armRight2,            tServoStandard)
#pragma config(Servo,  srvo_S2_C1_6,    Gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C2_4,    BackHolder1,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_5,    BackHolder2,          tServoStandard)
#pragma config(Servo,  srvo_S2_C2_6,    FrontHolder,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "AutonomousHeaders.h"				 //Include file which has headers such as global variables

#include "JoystickDriver.c"	          //Include file to "handle" the Bluetooth messages.

task main()
{
  //Uses the binary chop method to find the value needed
  eraseDisplay();
  bDisplayDiagnostics = false;
  bNxtLCDStatusDisplay = false;
  wait1Msec(100);
  eraseDisplay();
  nxtDisplayCenteredTextLine(1, "Press to begin");
  while (nNxtButtonPressed != Forward)
  {}
  int LowValue = 0;
  int encoderCount = 16;
  int HighValue = 40;
  bool terminate = false;

  while (terminate == false)
  {
    eraseDisplay();
    nxtDisplayCenteredTextLine(1, "Running...");
    while (abs(nMotorEncoder[LeftDrive]) <= (360 * encoderCount) && abs(nMotorEncoder[RightDrive]) <= (360 * encoderCount))
    {
      motor[LeftDrive] = 40;
      motor[RightDrive] = -40;
    }
    motor[LeftDrive] = 0;
    motor[RightDrive] = 0;
    eraseDisplay();
    nxtDisplayCenteredTextLine(1,"<- to reduce");
    nxtDisplayCenteredTextLine(2,"-> to increase");
    nxtDisplayCenteredTextLine(2,"ok to accept");
     while (1)
     {
       if (nNxtButtonPressed == Backward)
       {
         HighValue = encoderCount;
         encoderCount = (encoderCount + LowValue) / 2;
         eraseDisplay();
         break;
       }
       if (nNxtButtonPressed == Forward)
       {
         LowValue = encoderCount;
         encoderCount = (encoderCount + HighValue) / 2;
         eraseDisplay();
         break;
       }
        if (nNxtButtonPressed == Ok)
       {
         nxtDisplayCenteredTextLine(3, "Counts per degree: " + encoderCount);
         terminate = true;
         break;
       }
     }

  }
}
